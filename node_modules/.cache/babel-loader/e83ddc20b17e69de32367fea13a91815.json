{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _trackHelper = require('./trackHelper');\n\nvar _objectAssign = require('object-assign');\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar helpers = {\n  initialize: function initialize(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n\n    var slideCount = _react2.default.Children.count(props.children);\n\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n    var currentSlide = props.rtl ? slideCount - 1 - props.initialSlide : props.initialSlide;\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state)); // getCSS function needs previously set state\n\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n        left: targetLeft\n      }, props, this.state));\n      this.setState({\n        trackStyle: trackStyle\n      });\n      this.autoPlay(); // once we're set up, trigger the initial autoplay.\n    });\n  },\n  update: function update(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list); // This method has mostly same code as initialize method.\n    // Refactor it\n\n\n    var slideCount = _react2.default.Children.count(props.children);\n\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow; // pause slider if autoplay is set to false\n\n    if (!props.autoplay) {\n      this.pause();\n    } else {\n      this.autoPlay();\n    }\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state)); // getCSS function needs previously set state\n\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n        left: targetLeft\n      }, props, this.state));\n      this.setState({\n        trackStyle: trackStyle\n      });\n    });\n  },\n  getWidth: function getWidth(elem) {\n    return elem && (elem.getBoundingClientRect().width || elem.offsetWidth) || 0;\n  },\n  getHeight: function getHeight(elem) {\n    return elem && (elem.getBoundingClientRect().height || elem.offsetHeight) || 0;\n  },\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n\n      if (this.list) {\n        var slickList = _reactDom2.default.findDOMNode(this.list);\n\n        slickList.style.height = slickList.querySelector(selector).offsetHeight + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        // check if current slide is last slide\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else {\n        // check if all slides are shown in slider\n        if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n          canGo = false;\n        }\n      }\n    }\n\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this = this; // Functionality of animateSlide and postSlide is merged into this function\n    // console.log('slideHandler', index);\n\n\n    var targetSlide, currentSlide;\n    var targetLeft, currentLeft;\n    var callback;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.fade) {\n      currentSlide = this.state.currentSlide; // Don't change slide if it's not infite and current slide is the first or last slide.\n\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      } //  Shifting targetSlide back into the range\n\n\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this.setState({\n          animating: false\n        });\n\n        if (_this.props.afterChange) {\n          _this.props.afterChange(targetSlide);\n        }\n\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n\n      if (this.props.beforeChange) {\n        this.props.beforeChange(this.state.currentSlide, targetSlide);\n      }\n\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n\n    if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    currentLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.beforeChange) {\n      this.props.beforeChange(this.state.currentSlide, currentSlide);\n    }\n\n    if (this.props.lazyLoad) {\n      var loaded = true;\n      var slidesToLoad = [];\n\n      for (var i = targetSlide; i < targetSlide + this.props.slidesToShow; i++) {\n        loaded = loaded && this.state.lazyLoadedList.indexOf(i) >= 0;\n\n        if (!loaded) {\n          slidesToLoad.push(i);\n        }\n      }\n\n      if (!loaded) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    } // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n\n    if (this.props.useCSS === false) {\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n          left: currentLeft\n        }, this.props, this.state))\n      }, function () {\n        if (this.props.afterChange) {\n          this.props.afterChange(currentSlide);\n        }\n      });\n    } else {\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n          left: currentLeft\n        }, this.props, this.state)),\n        swipeLeft: null\n      };\n\n      callback = function callback() {\n        _this.setState(nextStateChanges);\n\n        if (_this.props.afterChange) {\n          _this.props.afterChange(currentSlide);\n        }\n\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackAnimateCSS)((0, _objectAssign2.default)({\n          left: targetLeft\n        }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n    }\n\n    this.autoPlay();\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    var xDist, yDist, r, swipeAngle;\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n    swipeAngle = Math.round(r * 180 / Math.PI);\n\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return this.props.rtl === false ? 'left' : 'right';\n    }\n\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return this.props.rtl === false ? 'right' : 'left';\n    }\n\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex;\n\n    if (!this.state.mounted) {\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else {\n      if (this.canGoNext(_extends({}, this.props, this.state))) {\n        nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n      } else {\n        return false;\n      }\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play, this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\nexports.default = helpers;","map":{"version":3,"sources":["C:/Users/Santosh Gupta/Downloads/sbsc-master/node_modules/react-slick/lib/mixins/helpers.js"],"names":["exports","__esModule","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_react","require","_react2","_interopRequireDefault","_reactDom","_reactDom2","_trackHelper","_objectAssign","_objectAssign2","obj","default","helpers","initialize","props","slickList","findDOMNode","list","slideCount","Children","count","children","listWidth","getWidth","trackWidth","track","slideWidth","vertical","centerPaddingAdj","centerMode","parseInt","centerPadding","slidesToShow","slideHeight","getHeight","querySelector","listHeight","currentSlide","rtl","initialSlide","setState","targetLeft","getTrackLeft","slideIndex","state","trackRef","trackStyle","getTrackCSS","left","autoPlay","update","autoplay","pause","elem","getBoundingClientRect","width","offsetWidth","height","offsetHeight","adaptHeight","adaptiveHeight","selector","style","canGoNext","opts","canGo","infinite","slideHandler","index","_this","targetSlide","currentLeft","callback","waitForAnimate","animating","fade","lazyLoad","lazyLoadedList","indexOf","concat","afterChange","animationEndCallback","setTimeout","speed","beforeChange","slidesToScroll","loaded","slidesToLoad","push","useCSS","nextStateChanges","swipeLeft","getTrackAnimateCSS","swipeDirection","touchObject","xDist","yDist","r","swipeAngle","startX","curX","startY","curY","Math","atan2","round","PI","abs","verticalSwiping","play","nextIndex","mounted","autoPlayTimer","clearTimeout","autoplaySpeed"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,SAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,UAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOL,MAAP;AAAgB,CAAhQ;;AAEA,IAAIS,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGC,sBAAsB,CAACH,MAAD,CAApC;;AAEA,IAAII,SAAS,GAAGH,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAII,UAAU,GAAGF,sBAAsB,CAACC,SAAD,CAAvC;;AAEA,IAAIE,YAAY,GAAGL,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAIM,aAAa,GAAGN,OAAO,CAAC,eAAD,CAA3B;;AAEA,IAAIO,cAAc,GAAGL,sBAAsB,CAACI,aAAD,CAA3C;;AAEA,SAASJ,sBAAT,CAAgCM,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACtB,UAAX,GAAwBsB,GAAxB,GAA8B;AAAEC,IAAAA,OAAO,EAAED;AAAX,GAArC;AAAwD;;AAE/F,IAAIE,OAAO,GAAG;AACZC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBC,KAApB,EAA2B;AACrC,QAAIC,SAAS,GAAGT,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,KAAKC,IAApC,CAAhB;;AAEA,QAAIC,UAAU,GAAGf,OAAO,CAACQ,OAAR,CAAgBQ,QAAhB,CAAyBC,KAAzB,CAA+BN,KAAK,CAACO,QAArC,CAAjB;;AACA,QAAIC,SAAS,GAAG,KAAKC,QAAL,CAAcR,SAAd,CAAhB;AACA,QAAIS,UAAU,GAAG,KAAKD,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,KAAKS,KAApC,CAAd,CAAjB;AACA,QAAIC,UAAJ;;AAEA,QAAI,CAACZ,KAAK,CAACa,QAAX,EAAqB;AACnB,UAAIC,gBAAgB,GAAGd,KAAK,CAACe,UAAN,IAAoBC,QAAQ,CAAChB,KAAK,CAACiB,aAAP,CAAR,GAAgC,CAA3E;AACAL,MAAAA,UAAU,GAAG,CAAC,KAAKH,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,IAA/B,CAAd,IAAsDY,gBAAvD,IAA2Ed,KAAK,CAACkB,YAA9F;AACD,KAHD,MAGO;AACLN,MAAAA,UAAU,GAAG,KAAKH,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,IAA/B,CAAd,CAAb;AACD;;AAED,QAAIiB,WAAW,GAAG,KAAKC,SAAL,CAAenB,SAAS,CAACoB,aAAV,CAAwB,kBAAxB,CAAf,CAAlB;AACA,QAAIC,UAAU,GAAGH,WAAW,GAAGnB,KAAK,CAACkB,YAArC;AAEA,QAAIK,YAAY,GAAGvB,KAAK,CAACwB,GAAN,GAAYpB,UAAU,GAAG,CAAb,GAAiBJ,KAAK,CAACyB,YAAnC,GAAkDzB,KAAK,CAACyB,YAA3E;AAEA,SAAKC,QAAL,CAAc;AACZtB,MAAAA,UAAU,EAAEA,UADA;AAEZQ,MAAAA,UAAU,EAAEA,UAFA;AAGZJ,MAAAA,SAAS,EAAEA,SAHC;AAIZE,MAAAA,UAAU,EAAEA,UAJA;AAKZa,MAAAA,YAAY,EAAEA,YALF;AAMZJ,MAAAA,WAAW,EAAEA,WAND;AAOZG,MAAAA,UAAU,EAAEA;AAPA,KAAd,EAQG,YAAY;AAEb,UAAIK,UAAU,GAAG,CAAC,GAAGlC,YAAY,CAACmC,YAAjB,EAA+B,CAAC,GAAGjC,cAAc,CAACE,OAAnB,EAA4B;AAC1EgC,QAAAA,UAAU,EAAE,KAAKC,KAAL,CAAWP,YADmD;AAE1EQ,QAAAA,QAAQ,EAAE,KAAKpB;AAF2D,OAA5B,EAG7CX,KAH6C,EAGtC,KAAK8B,KAHiC,CAA/B,CAAjB,CAFa,CAMb;;AACA,UAAIE,UAAU,GAAG,CAAC,GAAGvC,YAAY,CAACwC,WAAjB,EAA8B,CAAC,GAAGtC,cAAc,CAACE,OAAnB,EAA4B;AAAEqC,QAAAA,IAAI,EAAEP;AAAR,OAA5B,EAAkD3B,KAAlD,EAAyD,KAAK8B,KAA9D,CAA9B,CAAjB;AAEA,WAAKJ,QAAL,CAAc;AAAEM,QAAAA,UAAU,EAAEA;AAAd,OAAd;AAEA,WAAKG,QAAL,GAXa,CAWI;AAClB,KApBD;AAqBD,GA1CW;AA2CZC,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBpC,KAAhB,EAAuB;AAC7B,QAAIC,SAAS,GAAGT,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,KAAKC,IAApC,CAAhB,CAD6B,CAE7B;AACA;;;AACA,QAAIC,UAAU,GAAGf,OAAO,CAACQ,OAAR,CAAgBQ,QAAhB,CAAyBC,KAAzB,CAA+BN,KAAK,CAACO,QAArC,CAAjB;;AACA,QAAIC,SAAS,GAAG,KAAKC,QAAL,CAAcR,SAAd,CAAhB;AACA,QAAIS,UAAU,GAAG,KAAKD,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,KAAKS,KAApC,CAAd,CAAjB;AACA,QAAIC,UAAJ;;AAEA,QAAI,CAACZ,KAAK,CAACa,QAAX,EAAqB;AACnB,UAAIC,gBAAgB,GAAGd,KAAK,CAACe,UAAN,IAAoBC,QAAQ,CAAChB,KAAK,CAACiB,aAAP,CAAR,GAAgC,CAA3E;AACAL,MAAAA,UAAU,GAAG,CAAC,KAAKH,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,IAA/B,CAAd,IAAsDY,gBAAvD,IAA2Ed,KAAK,CAACkB,YAA9F;AACD,KAHD,MAGO;AACLN,MAAAA,UAAU,GAAG,KAAKH,QAAL,CAAcjB,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,IAA/B,CAAd,CAAb;AACD;;AAED,QAAIiB,WAAW,GAAG,KAAKC,SAAL,CAAenB,SAAS,CAACoB,aAAV,CAAwB,kBAAxB,CAAf,CAAlB;AACA,QAAIC,UAAU,GAAGH,WAAW,GAAGnB,KAAK,CAACkB,YAArC,CAjB6B,CAmB7B;;AACA,QAAI,CAAClB,KAAK,CAACqC,QAAX,EAAqB;AACnB,WAAKC,KAAL;AACD,KAFD,MAEO;AACL,WAAKH,QAAL;AACD;;AAED,SAAKT,QAAL,CAAc;AACZtB,MAAAA,UAAU,EAAEA,UADA;AAEZQ,MAAAA,UAAU,EAAEA,UAFA;AAGZJ,MAAAA,SAAS,EAAEA,SAHC;AAIZE,MAAAA,UAAU,EAAEA,UAJA;AAKZS,MAAAA,WAAW,EAAEA,WALD;AAMZG,MAAAA,UAAU,EAAEA;AANA,KAAd,EAOG,YAAY;AAEb,UAAIK,UAAU,GAAG,CAAC,GAAGlC,YAAY,CAACmC,YAAjB,EAA+B,CAAC,GAAGjC,cAAc,CAACE,OAAnB,EAA4B;AAC1EgC,QAAAA,UAAU,EAAE,KAAKC,KAAL,CAAWP,YADmD;AAE1EQ,QAAAA,QAAQ,EAAE,KAAKpB;AAF2D,OAA5B,EAG7CX,KAH6C,EAGtC,KAAK8B,KAHiC,CAA/B,CAAjB,CAFa,CAMb;;AACA,UAAIE,UAAU,GAAG,CAAC,GAAGvC,YAAY,CAACwC,WAAjB,EAA8B,CAAC,GAAGtC,cAAc,CAACE,OAAnB,EAA4B;AAAEqC,QAAAA,IAAI,EAAEP;AAAR,OAA5B,EAAkD3B,KAAlD,EAAyD,KAAK8B,KAA9D,CAA9B,CAAjB;AAEA,WAAKJ,QAAL,CAAc;AAAEM,QAAAA,UAAU,EAAEA;AAAd,OAAd;AACD,KAjBD;AAkBD,GAvFW;AAwFZvB,EAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkB8B,IAAlB,EAAwB;AAChC,WAAOA,IAAI,KAAKA,IAAI,CAACC,qBAAL,GAA6BC,KAA7B,IAAsCF,IAAI,CAACG,WAAhD,CAAJ,IAAoE,CAA3E;AACD,GA1FW;AA2FZtB,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBmB,IAAnB,EAAyB;AAClC,WAAOA,IAAI,KAAKA,IAAI,CAACC,qBAAL,GAA6BG,MAA7B,IAAuCJ,IAAI,CAACK,YAAjD,CAAJ,IAAsE,CAA7E;AACD,GA7FW;AA+FZC,EAAAA,WAAW,EAAE,SAASA,WAAT,GAAuB;AAClC,QAAI,KAAK7C,KAAL,CAAW8C,cAAf,EAA+B;AAC7B,UAAIC,QAAQ,GAAG,kBAAkB,KAAKjB,KAAL,CAAWP,YAA7B,GAA4C,IAA3D;;AACA,UAAI,KAAKpB,IAAT,EAAe;AACb,YAAIF,SAAS,GAAGT,UAAU,CAACK,OAAX,CAAmBK,WAAnB,CAA+B,KAAKC,IAApC,CAAhB;;AACAF,QAAAA,SAAS,CAAC+C,KAAV,CAAgBL,MAAhB,GAAyB1C,SAAS,CAACoB,aAAV,CAAwB0B,QAAxB,EAAkCH,YAAlC,GAAiD,IAA1E;AACD;AACF;AACF,GAvGW;AAwGZK,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBC,IAAnB,EAAyB;AAClC,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAI,CAACD,IAAI,CAACE,QAAV,EAAoB;AAClB,UAAIF,IAAI,CAACnC,UAAT,EAAqB;AACnB;AACA,YAAImC,IAAI,CAAC3B,YAAL,IAAqB2B,IAAI,CAAC9C,UAAL,GAAkB,CAA3C,EAA8C;AAC5C+C,UAAAA,KAAK,GAAG,KAAR;AACD;AACF,OALD,MAKO;AACL;AACA,YAAID,IAAI,CAAC9C,UAAL,IAAmB8C,IAAI,CAAChC,YAAxB,IAAwCgC,IAAI,CAAC3B,YAAL,IAAqB2B,IAAI,CAAC9C,UAAL,GAAkB8C,IAAI,CAAChC,YAAxF,EAAsG;AACpGiC,UAAAA,KAAK,GAAG,KAAR;AACD;AACF;AACF;;AACD,WAAOA,KAAP;AACD,GAxHW;AAyHZE,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,KAAtB,EAA6B;AACzC,QAAIC,KAAK,GAAG,IAAZ,CADyC,CAGzC;AACA;;;AACA,QAAIC,WAAJ,EAAiBjC,YAAjB;AACA,QAAII,UAAJ,EAAgB8B,WAAhB;AACA,QAAIC,QAAJ;;AAEA,QAAI,KAAK1D,KAAL,CAAW2D,cAAX,IAA6B,KAAK7B,KAAL,CAAW8B,SAA5C,EAAuD;AACrD;AACD;;AAED,QAAI,KAAK5D,KAAL,CAAW6D,IAAf,EAAqB;AACnBtC,MAAAA,YAAY,GAAG,KAAKO,KAAL,CAAWP,YAA1B,CADmB,CAGnB;;AACA,UAAI,KAAKvB,KAAL,CAAWoD,QAAX,KAAwB,KAAxB,KAAkCE,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI,KAAKxB,KAAL,CAAW1B,UAAnE,CAAJ,EAAoF;AAClF;AACD,OANkB,CAQnB;;;AACA,UAAIkD,KAAK,GAAG,CAAZ,EAAe;AACbE,QAAAA,WAAW,GAAGF,KAAK,GAAG,KAAKxB,KAAL,CAAW1B,UAAjC;AACD,OAFD,MAEO,IAAIkD,KAAK,IAAI,KAAKxB,KAAL,CAAW1B,UAAxB,EAAoC;AACzCoD,QAAAA,WAAW,GAAGF,KAAK,GAAG,KAAKxB,KAAL,CAAW1B,UAAjC;AACD,OAFM,MAEA;AACLoD,QAAAA,WAAW,GAAGF,KAAd;AACD;;AAED,UAAI,KAAKtD,KAAL,CAAW8D,QAAX,IAAuB,KAAKhC,KAAL,CAAWiC,cAAX,CAA0BC,OAA1B,CAAkCR,WAAlC,IAAiD,CAA5E,EAA+E;AAC7E,aAAK9B,QAAL,CAAc;AACZqC,UAAAA,cAAc,EAAE,KAAKjC,KAAL,CAAWiC,cAAX,CAA0BE,MAA1B,CAAiCT,WAAjC;AADJ,SAAd;AAGD;;AAEDE,MAAAA,QAAQ,GAAG,SAASA,QAAT,GAAoB;AAC7BH,QAAAA,KAAK,CAAC7B,QAAN,CAAe;AACbkC,UAAAA,SAAS,EAAE;AADE,SAAf;;AAGA,YAAIL,KAAK,CAACvD,KAAN,CAAYkE,WAAhB,EAA6B;AAC3BX,UAAAA,KAAK,CAACvD,KAAN,CAAYkE,WAAZ,CAAwBV,WAAxB;AACD;;AACD,eAAOD,KAAK,CAACY,oBAAb;AACD,OARD;;AAUA,WAAKzC,QAAL,CAAc;AACZkC,QAAAA,SAAS,EAAE,IADC;AAEZrC,QAAAA,YAAY,EAAEiC;AAFF,OAAd,EAGG,YAAY;AACb,aAAKW,oBAAL,GAA4BC,UAAU,CAACV,QAAD,EAAW,KAAK1D,KAAL,CAAWqE,KAAtB,CAAtC;AACD,OALD;;AAOA,UAAI,KAAKrE,KAAL,CAAWsE,YAAf,EAA6B;AAC3B,aAAKtE,KAAL,CAAWsE,YAAX,CAAwB,KAAKxC,KAAL,CAAWP,YAAnC,EAAiDiC,WAAjD;AACD;;AAED,WAAKrB,QAAL;AACA;AACD;;AAEDqB,IAAAA,WAAW,GAAGF,KAAd;;AACA,QAAIE,WAAW,GAAG,CAAlB,EAAqB;AACnB,UAAI,KAAKxD,KAAL,CAAWoD,QAAX,KAAwB,KAA5B,EAAmC;AACjC7B,QAAAA,YAAY,GAAG,CAAf;AACD,OAFD,MAEO,IAAI,KAAKO,KAAL,CAAW1B,UAAX,GAAwB,KAAKJ,KAAL,CAAWuE,cAAnC,KAAsD,CAA1D,EAA6D;AAClEhD,QAAAA,YAAY,GAAG,KAAKO,KAAL,CAAW1B,UAAX,GAAwB,KAAK0B,KAAL,CAAW1B,UAAX,GAAwB,KAAKJ,KAAL,CAAWuE,cAA1E;AACD,OAFM,MAEA;AACLhD,QAAAA,YAAY,GAAG,KAAKO,KAAL,CAAW1B,UAAX,GAAwBoD,WAAvC;AACD;AACF,KARD,MAQO,IAAIA,WAAW,IAAI,KAAK1B,KAAL,CAAW1B,UAA9B,EAA0C;AAC/C,UAAI,KAAKJ,KAAL,CAAWoD,QAAX,KAAwB,KAA5B,EAAmC;AACjC7B,QAAAA,YAAY,GAAG,KAAKO,KAAL,CAAW1B,UAAX,GAAwB,KAAKJ,KAAL,CAAWkB,YAAlD;AACD,OAFD,MAEO,IAAI,KAAKY,KAAL,CAAW1B,UAAX,GAAwB,KAAKJ,KAAL,CAAWuE,cAAnC,KAAsD,CAA1D,EAA6D;AAClEhD,QAAAA,YAAY,GAAG,CAAf;AACD,OAFM,MAEA;AACLA,QAAAA,YAAY,GAAGiC,WAAW,GAAG,KAAK1B,KAAL,CAAW1B,UAAxC;AACD;AACF,KARM,MAQA;AACLmB,MAAAA,YAAY,GAAGiC,WAAf;AACD;;AAED7B,IAAAA,UAAU,GAAG,CAAC,GAAGlC,YAAY,CAACmC,YAAjB,EAA+B,CAAC,GAAGjC,cAAc,CAACE,OAAnB,EAA4B;AACtEgC,MAAAA,UAAU,EAAE2B,WAD0D;AAEtEzB,MAAAA,QAAQ,EAAE,KAAKpB;AAFuD,KAA5B,EAGzC,KAAKX,KAHoC,EAG7B,KAAK8B,KAHwB,CAA/B,CAAb;AAKA2B,IAAAA,WAAW,GAAG,CAAC,GAAGhE,YAAY,CAACmC,YAAjB,EAA+B,CAAC,GAAGjC,cAAc,CAACE,OAAnB,EAA4B;AACvEgC,MAAAA,UAAU,EAAEN,YAD2D;AAEvEQ,MAAAA,QAAQ,EAAE,KAAKpB;AAFwD,KAA5B,EAG1C,KAAKX,KAHqC,EAG9B,KAAK8B,KAHyB,CAA/B,CAAd;;AAKA,QAAI,KAAK9B,KAAL,CAAWoD,QAAX,KAAwB,KAA5B,EAAmC;AACjCzB,MAAAA,UAAU,GAAG8B,WAAb;AACD;;AAED,QAAI,KAAKzD,KAAL,CAAWsE,YAAf,EAA6B;AAC3B,WAAKtE,KAAL,CAAWsE,YAAX,CAAwB,KAAKxC,KAAL,CAAWP,YAAnC,EAAiDA,YAAjD;AACD;;AAED,QAAI,KAAKvB,KAAL,CAAW8D,QAAf,EAAyB;AACvB,UAAIU,MAAM,GAAG,IAAb;AACA,UAAIC,YAAY,GAAG,EAAnB;;AACA,WAAK,IAAI9F,CAAC,GAAG6E,WAAb,EAA0B7E,CAAC,GAAG6E,WAAW,GAAG,KAAKxD,KAAL,CAAWkB,YAAvD,EAAqEvC,CAAC,EAAtE,EAA0E;AACxE6F,QAAAA,MAAM,GAAGA,MAAM,IAAI,KAAK1C,KAAL,CAAWiC,cAAX,CAA0BC,OAA1B,CAAkCrF,CAAlC,KAAwC,CAA3D;;AACA,YAAI,CAAC6F,MAAL,EAAa;AACXC,UAAAA,YAAY,CAACC,IAAb,CAAkB/F,CAAlB;AACD;AACF;;AACD,UAAI,CAAC6F,MAAL,EAAa;AACX,aAAK9C,QAAL,CAAc;AACZqC,UAAAA,cAAc,EAAE,KAAKjC,KAAL,CAAWiC,cAAX,CAA0BE,MAA1B,CAAiCQ,YAAjC;AADJ,SAAd;AAGD;AACF,KAlHwC,CAoHzC;AACA;AACA;AACA;;;AAEA,QAAI,KAAKzE,KAAL,CAAW2E,MAAX,KAAsB,KAA1B,EAAiC;AAE/B,WAAKjD,QAAL,CAAc;AACZH,QAAAA,YAAY,EAAEA,YADF;AAEZS,QAAAA,UAAU,EAAE,CAAC,GAAGvC,YAAY,CAACwC,WAAjB,EAA8B,CAAC,GAAGtC,cAAc,CAACE,OAAnB,EAA4B;AAAEqC,UAAAA,IAAI,EAAEuB;AAAR,SAA5B,EAAmD,KAAKzD,KAAxD,EAA+D,KAAK8B,KAApE,CAA9B;AAFA,OAAd,EAGG,YAAY;AACb,YAAI,KAAK9B,KAAL,CAAWkE,WAAf,EAA4B;AAC1B,eAAKlE,KAAL,CAAWkE,WAAX,CAAuB3C,YAAvB;AACD;AACF,OAPD;AAQD,KAVD,MAUO;AAEL,UAAIqD,gBAAgB,GAAG;AACrBhB,QAAAA,SAAS,EAAE,KADU;AAErBrC,QAAAA,YAAY,EAAEA,YAFO;AAGrBS,QAAAA,UAAU,EAAE,CAAC,GAAGvC,YAAY,CAACwC,WAAjB,EAA8B,CAAC,GAAGtC,cAAc,CAACE,OAAnB,EAA4B;AAAEqC,UAAAA,IAAI,EAAEuB;AAAR,SAA5B,EAAmD,KAAKzD,KAAxD,EAA+D,KAAK8B,KAApE,CAA9B,CAHS;AAIrB+C,QAAAA,SAAS,EAAE;AAJU,OAAvB;;AAOAnB,MAAAA,QAAQ,GAAG,SAASA,QAAT,GAAoB;AAC7BH,QAAAA,KAAK,CAAC7B,QAAN,CAAekD,gBAAf;;AACA,YAAIrB,KAAK,CAACvD,KAAN,CAAYkE,WAAhB,EAA6B;AAC3BX,UAAAA,KAAK,CAACvD,KAAN,CAAYkE,WAAZ,CAAwB3C,YAAxB;AACD;;AACD,eAAOgC,KAAK,CAACY,oBAAb;AACD,OAND;;AAQA,WAAKzC,QAAL,CAAc;AACZkC,QAAAA,SAAS,EAAE,IADC;AAEZrC,QAAAA,YAAY,EAAEA,YAFF;AAGZS,QAAAA,UAAU,EAAE,CAAC,GAAGvC,YAAY,CAACqF,kBAAjB,EAAqC,CAAC,GAAGnF,cAAc,CAACE,OAAnB,EAA4B;AAAEqC,UAAAA,IAAI,EAAEP;AAAR,SAA5B,EAAkD,KAAK3B,KAAvD,EAA8D,KAAK8B,KAAnE,CAArC;AAHA,OAAd,EAIG,YAAY;AACb,aAAKqC,oBAAL,GAA4BC,UAAU,CAACV,QAAD,EAAW,KAAK1D,KAAL,CAAWqE,KAAtB,CAAtC;AACD,OAND;AAOD;;AAED,SAAKlC,QAAL;AACD,GAvRW;AAwRZ4C,EAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,WAAxB,EAAqC;AACnD,QAAIC,KAAJ,EAAWC,KAAX,EAAkBC,CAAlB,EAAqBC,UAArB;AAEAH,IAAAA,KAAK,GAAGD,WAAW,CAACK,MAAZ,GAAqBL,WAAW,CAACM,IAAzC;AACAJ,IAAAA,KAAK,GAAGF,WAAW,CAACO,MAAZ,GAAqBP,WAAW,CAACQ,IAAzC;AACAL,IAAAA,CAAC,GAAGM,IAAI,CAACC,KAAL,CAAWR,KAAX,EAAkBD,KAAlB,CAAJ;AAEAG,IAAAA,UAAU,GAAGK,IAAI,CAACE,KAAL,CAAWR,CAAC,GAAG,GAAJ,GAAUM,IAAI,CAACG,EAA1B,CAAb;;AACA,QAAIR,UAAU,GAAG,CAAjB,EAAoB;AAClBA,MAAAA,UAAU,GAAG,MAAMK,IAAI,CAACI,GAAL,CAAST,UAAT,CAAnB;AACD;;AACD,QAAIA,UAAU,IAAI,EAAd,IAAoBA,UAAU,IAAI,CAAlC,IAAuCA,UAAU,IAAI,GAAd,IAAqBA,UAAU,IAAI,GAA9E,EAAmF;AACjF,aAAO,KAAKpF,KAAL,CAAWwB,GAAX,KAAmB,KAAnB,GAA2B,MAA3B,GAAoC,OAA3C;AACD;;AACD,QAAI4D,UAAU,IAAI,GAAd,IAAqBA,UAAU,IAAI,GAAvC,EAA4C;AAC1C,aAAO,KAAKpF,KAAL,CAAWwB,GAAX,KAAmB,KAAnB,GAA2B,OAA3B,GAAqC,MAA5C;AACD;;AACD,QAAI,KAAKxB,KAAL,CAAW8F,eAAX,KAA+B,IAAnC,EAAyC;AACvC,UAAIV,UAAU,IAAI,EAAd,IAAoBA,UAAU,IAAI,GAAtC,EAA2C;AACzC,eAAO,MAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;;AAED,WAAO,UAAP;AACD,GAlTW;AAmTZW,EAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB;AACpB,QAAIC,SAAJ;;AAEA,QAAI,CAAC,KAAKlE,KAAL,CAAWmE,OAAhB,EAAyB;AACvB,aAAO,KAAP;AACD;;AAED,QAAI,KAAKjG,KAAL,CAAWwB,GAAf,EAAoB;AAClBwE,MAAAA,SAAS,GAAG,KAAKlE,KAAL,CAAWP,YAAX,GAA0B,KAAKvB,KAAL,CAAWuE,cAAjD;AACD,KAFD,MAEO;AACL,UAAI,KAAKtB,SAAL,CAAe1E,QAAQ,CAAC,EAAD,EAAK,KAAKyB,KAAV,EAAiB,KAAK8B,KAAtB,CAAvB,CAAJ,EAA0D;AACxDkE,QAAAA,SAAS,GAAG,KAAKlE,KAAL,CAAWP,YAAX,GAA0B,KAAKvB,KAAL,CAAWuE,cAAjD;AACD,OAFD,MAEO;AACL,eAAO,KAAP;AACD;AACF;;AAED,SAAKlB,YAAL,CAAkB2C,SAAlB;AACD,GArUW;AAsUZ7D,EAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,QAAI,KAAKL,KAAL,CAAWoE,aAAf,EAA8B;AAC5BC,MAAAA,YAAY,CAAC,KAAKrE,KAAL,CAAWoE,aAAZ,CAAZ;AACD;;AACD,QAAI,KAAKlG,KAAL,CAAWqC,QAAf,EAAyB;AACvB,WAAKX,QAAL,CAAc;AACZwE,QAAAA,aAAa,EAAE9B,UAAU,CAAC,KAAK2B,IAAN,EAAY,KAAK/F,KAAL,CAAWoG,aAAvB;AADb,OAAd;AAGD;AACF,GA/UW;AAgVZ9D,EAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB,QAAI,KAAKR,KAAL,CAAWoE,aAAf,EAA8B;AAC5BC,MAAAA,YAAY,CAAC,KAAKrE,KAAL,CAAWoE,aAAZ,CAAZ;AACA,WAAKxE,QAAL,CAAc;AACZwE,QAAAA,aAAa,EAAE;AADH,OAAd;AAGD;AACF;AAvVW,CAAd;AA0VA7H,OAAO,CAACwB,OAAR,GAAkBC,OAAlB","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _trackHelper = require('./trackHelper');\n\nvar _objectAssign = require('object-assign');\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar helpers = {\n  initialize: function initialize(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n\n    var slideCount = _react2.default.Children.count(props.children);\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n\n    var currentSlide = props.rtl ? slideCount - 1 - props.initialSlide : props.initialSlide;\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state));\n      // getCSS function needs previously set state\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: targetLeft }, props, this.state));\n\n      this.setState({ trackStyle: trackStyle });\n\n      this.autoPlay(); // once we're set up, trigger the initial autoplay.\n    });\n  },\n  update: function update(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n    // This method has mostly same code as initialize method.\n    // Refactor it\n    var slideCount = _react2.default.Children.count(props.children);\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n\n    // pause slider if autoplay is set to false\n    if (!props.autoplay) {\n      this.pause();\n    } else {\n      this.autoPlay();\n    }\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state));\n      // getCSS function needs previously set state\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: targetLeft }, props, this.state));\n\n      this.setState({ trackStyle: trackStyle });\n    });\n  },\n  getWidth: function getWidth(elem) {\n    return elem && (elem.getBoundingClientRect().width || elem.offsetWidth) || 0;\n  },\n  getHeight: function getHeight(elem) {\n    return elem && (elem.getBoundingClientRect().height || elem.offsetHeight) || 0;\n  },\n\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n      if (this.list) {\n        var slickList = _reactDom2.default.findDOMNode(this.list);\n        slickList.style.height = slickList.querySelector(selector).offsetHeight + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        // check if current slide is last slide\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else {\n        // check if all slides are shown in slider\n        if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n          canGo = false;\n        }\n      }\n    }\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this = this;\n\n    // Functionality of animateSlide and postSlide is merged into this function\n    // console.log('slideHandler', index);\n    var targetSlide, currentSlide;\n    var targetLeft, currentLeft;\n    var callback;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.fade) {\n      currentSlide = this.state.currentSlide;\n\n      // Don't change slide if it's not infite and current slide is the first or last slide.\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      }\n\n      //  Shifting targetSlide back into the range\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this.setState({\n          animating: false\n        });\n        if (_this.props.afterChange) {\n          _this.props.afterChange(targetSlide);\n        }\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n\n      if (this.props.beforeChange) {\n        this.props.beforeChange(this.state.currentSlide, targetSlide);\n      }\n\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n    if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    currentLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.beforeChange) {\n      this.props.beforeChange(this.state.currentSlide, currentSlide);\n    }\n\n    if (this.props.lazyLoad) {\n      var loaded = true;\n      var slidesToLoad = [];\n      for (var i = targetSlide; i < targetSlide + this.props.slidesToShow; i++) {\n        loaded = loaded && this.state.lazyLoadedList.indexOf(i) >= 0;\n        if (!loaded) {\n          slidesToLoad.push(i);\n        }\n      }\n      if (!loaded) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    }\n\n    // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n    if (this.props.useCSS === false) {\n\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: currentLeft }, this.props, this.state))\n      }, function () {\n        if (this.props.afterChange) {\n          this.props.afterChange(currentSlide);\n        }\n      });\n    } else {\n\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: currentLeft }, this.props, this.state)),\n        swipeLeft: null\n      };\n\n      callback = function callback() {\n        _this.setState(nextStateChanges);\n        if (_this.props.afterChange) {\n          _this.props.afterChange(currentSlide);\n        }\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackAnimateCSS)((0, _objectAssign2.default)({ left: targetLeft }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n    }\n\n    this.autoPlay();\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    var xDist, yDist, r, swipeAngle;\n\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n\n    swipeAngle = Math.round(r * 180 / Math.PI);\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return this.props.rtl === false ? 'left' : 'right';\n    }\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return this.props.rtl === false ? 'right' : 'left';\n    }\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex;\n\n    if (!this.state.mounted) {\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else {\n      if (this.canGoNext(_extends({}, this.props, this.state))) {\n        nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n      } else {\n        return false;\n      }\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play, this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\n\nexports.default = helpers;"]},"metadata":{},"sourceType":"script"}